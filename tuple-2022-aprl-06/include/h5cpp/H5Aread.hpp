/*
 * Copyright (c) 2018 - 2021 vargaconsulting, Toronto,ON Canada
 * Author: Varga, Steven <steven@vargaconsulting.ca>
 */
#ifndef  H5CPP_AREAD_HPP
#define  H5CPP_AREAD_HPP

#include <hdf5.h>
#include "H5config.hpp"
#include "H5Eall.hpp"
#include "H5Iall.hpp"
#include "H5Sall.hpp"
#include "H5Tall.hpp"
#include "H5Tmeta.hpp"
#include "H5Aopen.hpp"
#include <type_traits>
#include <string>
#include <stdexcept>
#include <stdlib.h>

namespace h5 {
/*
    //ARITHMETIC ELEMENT TYPES 
    template <class T,  class HID_T, class... args_t> inline
    typename std::enable_if< meta:is_arithmetic<T>::value && impl::attr::is_location<HID_T>::value,
        T>::type aread( const HID_T& ds, const std::string& name, const h5::acpl_t& acpl = h5::default_acpl ){

        h5::at_t attr = h5::aopen(ds, name, h5::default_acpl);
        hid_t id;
        H5CPP_CHECK_NZ( (id = H5Aget_space( static_cast<hid_t>(attr) )),
               h5::error::io::attribute::read, "couldn't get space...");
        h5::sp_t file_space{id};
        h5::current_dims_t current_dims;

        int rank = get_simple_extent_dims(file_space, current_dims );
        using element_t = typename meta::decay<T>::type;
        h5::dt_t<element_t> type;
        T object = meta::get<T>::ctor( current_dims );
        element_t *ptr = const_cast<element_t*>( meta::data( object ));
        H5CPP_CHECK_NZ( H5Aread( static_cast<hid_t>(attr), static_cast<hid_t>(type), ptr ),
               h5::error::io::attribute::read, "couldn't read attribute ...");
        return object;
    }
*/
    //POD ELEMENT TYPES: Rank 0 and rank > 0 btw: strings are not pods 
    template <class T, class D=typename meta::decay<T>::type, class HID_T, class... args_t> inline
    typename std::enable_if< impl::attr::is_location<HID_T>::value,
    T>::type aread( const HID_T& ds, const std::string& name, const h5::acpl_t& acpl = h5::default_acpl ){
        h5::at_t attr = h5::aopen(ds, name, h5::default_acpl);
        hid_t id;
        H5CPP_CHECK_NZ( (id = H5Aget_space( static_cast<hid_t>(attr) )),
               h5::error::io::attribute::read, "couldn't get space...");
        h5::sp_t file_space{id};
        h5::current_dims_t current_dims;
        int rank = get_simple_extent_dims(file_space, current_dims );
        using element_t = typename meta::decay<T>::type;
        h5::dt_t<element_t> type;
        if( !rank ){ // FIXME: write meta::get<pod_type>(...)
            T object;
            H5CPP_CHECK_NZ( H5Aread( static_cast<hid_t>(attr), static_cast<hid_t>(type), &object ),
                   h5::error::io::attribute::read, "couldn't read attribute ...");
            return object;
        }else{ // we are dealing with rank 0 or single object
            T object = meta::get<T>::ctor( current_dims );
            element_t *ptr = const_cast<element_t*>( meta::data( object ));
            H5CPP_CHECK_NZ( H5Aread( static_cast<hid_t>(attr), static_cast<hid_t>(type), ptr ),
                   h5::error::io::attribute::read, "couldn't read attribute ...");
            return object;
        }
    }

    // STD::STRING: SCALAR
    template <class T, class HID_T, class... args_t> inline
    typename std::enable_if<meta::is_string<T>::value && meta::is_scalar<T>::value && h5::impl::is_valid_attr<HID_T>::value, //TODO: add char**
    T>::type aread( const HID_T& ds, const std::string& name, const h5::acpl_t& acpl = h5::default_acpl ){
        h5::at_t attr = h5::aopen(ds, name, h5::default_acpl);
        h5::dt_t<char*> type; // gets variable length string
        char* ptr;
        H5CPP_CHECK_NZ( H5Aread( static_cast<hid_t>(attr), static_cast<hid_t>(type), &ptr ),
               h5::error::io::attribute::read, "couldn't read attribute ...");
        return std::string(ptr);
    }

    // STD::STRING: NOT SCALAR
    template <class T, class HID_T, class... args_t> inline
    typename std::enable_if<meta::is_string<T>::value && !meta::is_scalar<T>::value && h5::impl::is_valid_attr<HID_T>::value, //TODO: add char**
    T>::type aread( const HID_T& ds, const std::string& name, const h5::acpl_t& acpl = h5::default_acpl ){
        h5::at_t attr = h5::aopen(ds, name, h5::default_acpl);
        hid_t id;
        H5CPP_CHECK_NZ( (id = H5Aget_space( static_cast<hid_t>(attr) )),
               h5::error::io::attribute::read, "couldn't get space...");
        h5::sp_t file_space{id};
        h5::current_dims_t current_dims;
        int rank = get_simple_extent_dims(file_space, current_dims );
        using element_t = typename meta::decay<T>::type;
        h5::dt_t<char*> type;
        T object = meta::get<T>::ctor( current_dims );
        size_t nelem = impl::nelements(current_dims);
        char** ptr = static_cast<char**>( malloc ( nelem * sizeof (char *)));
        H5CPP_CHECK_NZ( H5Aread( static_cast<hid_t>(attr), static_cast<hid_t>(type), ptr ),
               h5::error::io::attribute::read, "couldn't read attribute ...");
        for( size_t i=0; i<nelem; i++)
            if( ptr[i] != NULL ) object[i] = std::string( ptr[i] );
        free(ptr);
        return object;
    }

}
#endif

